/**@format */

const fs = require("fs");
const path = require("path");
const definition = require("../utils/define");

const fileReader = require("../utils/fileReader");

const args = process.argv;
const configuration = require("../../../resource/features/config.json");
const globalConfig = require("../../../config/res.config.json");

const FEATURE_SOURCE_PATH = "../../../resource/features";
const FEATURE_RES_PATH_RELATION = `${definition.TIANYU_NATIVE_NATIVE_RES_PATH}/${definition.TIANYU_NATIVE_NATIVE_RES_FEATURE_NAME}`;

function processFeatureStatus(features) {
    const featureStatus = {};

    const fnProcessInternal = (featureStatusList, featureName) => {
        if (featureStatus[featureName]) {
            return featureStatus[featureName];
        }

        const featureState = features[featureName];
        const featureDependency = featureState.depends;

        let bDependentFeatureState = true;
        if (featureDependency) {
            for (let i = 0; bDependentFeatureState && i < featureDependency.length; ++i) {
                bDependentFeatureState = fnProcessInternal(featureStatusList, featureDependency[i]);
            }
        }

        return bDependentFeatureState && featureState.defaultOn;
    };

    for (const featureName of Object.keys(features)) {
        if (featureStatus[featureName]) {
            continue;
        }
        const state = fnProcessInternal(featureStatus, featureName);
        featureStatus[featureName] = state;
    }

    return featureStatus;
}

function createTargetContent(id, aData, desc) {
    try {
        desc = desc || [];

        const aResultLines = [];
        const date = new Date(Date.now());

        aResultLines.push("// #####################################################");
        for (const descItem of desc) aResultLines.push(`// ${descItem}`);
        aResultLines.push("//");
        aResultLines.push(`// 文件创建时间:   ${date.toDateString()}`);
        aResultLines.push(`// 版       权:   aitianyu.cn`);
        aResultLines.push("//");
        aResultLines.push(`// Create Time:  ${date.toDateString()}`);
        aResultLines.push(`// Copyright  :  aitianyu.cn`);
        aResultLines.push("//");
        aResultLines.push("// 此文件由天宇自动化生成器生成，请勿手动更改");
        aResultLines.push("// This file is generated by Tianyu Automatic Creater");
        aResultLines.push("// Please do NOT manually change");
        aResultLines.push("//");
        aResultLines.push("// #####################################################");
        aResultLines.push("");

        const fileMacroDef = `__TIANYU_COMMON_NATIVE_RES_FEATURE_${id}_H__`;
        aResultLines.push(`#ifndef ${fileMacroDef}`);
        aResultLines.push(`#define ${fileMacroDef}`);
        aResultLines.push("");

        const aCppDefine = [];
        const aCDefine = [];
        for (const item of aData) {
            const sourceFile = item.source;
            const jsonData = item.data;
            const features = processFeatureStatus(jsonData);

            definition.FULL_CONSOLE_LOG && console.log(`       - detected source file: ${sourceFile} to ${id}`);

            aResultLines.push(`// ${sourceFile}.json`);

            for (const key of Object.keys(jsonData)) {
                const value = jsonData[key];
                const version = value["version"] || "Unknown";
                const require = value["require"] || "Unknown";
                const description = value["description"] || "Unknown";
                const status = features[key] ?? false;

                aCppDefine.push("/**");
                aCppDefine.push(` * @brief ${description}`);
                aCppDefine.push(` * @version ${version}`);
                aCppDefine.push(` * @require ${require}`);
                aCppDefine.push(" */");
                aCppDefine.push(`#define ${key} ${status ? true : false}`);

                aCDefine.push("/**");
                aCDefine.push(` * @brief ${description}`);
                aCDefine.push(` * @version ${version}`);
                aCDefine.push(` * @require ${require}`);
                aCDefine.push(" */");
                aCDefine.push(`#define ${key} ${status ? 1 : 0}`);
            }

            aCppDefine.push("");
            aCDefine.push("");
        }

        aResultLines.push("#ifdef __cplusplus");
        aResultLines.push(...aCppDefine);
        aResultLines.push("#else");
        aResultLines.push(...aCDefine);
        aResultLines.push("#endif // !__cplusplus");

        aResultLines.push(`#endif // !${fileMacroDef}`);

        return aResultLines.join("\r\n");
    } catch (e) {
        console.log(e);
    }
}

// return: {file: target file, status: boolean}
async function generateTarget(id, source, target, desc) {
    const targetFile = `feature_${target}.h`;
    console.log(`     ** start build ${targetFile} **`);

    return fileReader.readFiles(source, FEATURE_SOURCE_PATH).then(
        async (aData) => {
            const targetPath = path.resolve(__dirname, FEATURE_RES_PATH_RELATION, targetFile);
            try {
                const content = createTargetContent(id, aData, desc);

                definition.FULL_CONSOLE_LOG && console.log(`        # handle data for target file :${targetFile} SUCCESS`);
                return new Promise((resolve) => {
                    fs.writeFile(
                        targetPath,
                        content,
                        {
                            encoding: "utf-8",
                        },
                        (err) => {
                            if (!!err) {
                                console.error(`        fs.writeFile cause an Error ${targetFile}. ${err}`);
                            } else {
                                definition.FULL_CONSOLE_LOG && console.log(`        # write into file :${targetFile} SUCCESS`);
                            }

                            console.log(`     ** build ${targetFile} end **`);
                            resolve({ file: targetFile, status: !!!err });
                        },
                    );
                });
            } catch (e) {
                console.error(`       # write file ${targetPath} failed. ${e.message}`);
                console.log(`     ** build ${targetFile} end **`);
                return Promise.resolve({ file: targetFile, status: false });
            }
        },
        async () => {
            return Promise.resolve({ file: targetFile, status: false });
        },
    );
}

async function run() {
    const aTargetHeaders = [];
    const aGenerationPromise = [];
    const targetids = Object.keys(configuration);

    console.log("     ** feature preparing start **");
    for (const targetId of targetids) {
        const option = configuration[targetId];
        const source = option.source || [];
        const desc = option.description || [];
        const target = option.target;

        if (!!!targetId || !!!source.length || !!!target) {
            continue;
        }

        const generationPromise = generateTarget(
            targetId.toUpperCase().replace(" ", "_").replace("-", "_"),
            source,
            target,
            desc,
        );
        aGenerationPromise.push(generationPromise);
    }

    await Promise.all(aGenerationPromise).then(
        async (aResults) => {
            console.log("     ** feature preparing done **");
            console.log();
            console.log("     ** feature process start **");
            let hasError = false;
            for (const result of aResults) {
                console.log(`       build feature file ${result.file} ${result.status ? "SUCCESS" : "FAILURE"}`);
                hasError = hasError || result.status;
                if (result.status) {
                    aTargetHeaders.push(result.file);
                }
            }

            await new Promise((resolve) => {
                console.log();

                const targetPath = path.resolve(__dirname, FEATURE_RES_PATH_RELATION, `list.lock.json`);
                console.log(`     build list file`);
                fs.writeFile(targetPath, JSON.stringify(aTargetHeaders), { encoding: "utf-8" }, (err) => {
                    if (!!err) {
                        console.error(`     fs.writeFile cause an Error ${target}. ${err}`);
                    } else {
                        console.log("     build list file SUCCESS");
                    }

                    console.log();
                    console.log(`     ** feature process ${hasError ? "succes" : "failed"} **`);
                    resolve();
                });
            });
        },
        (err) => {
            console.log("     ** feature preparing done **");
            console.log();
            console.log("     features Process Failed!!!");
            console.error(`     auto operations failed. ${err}`);
        },
    );
}

module.exports.build = async function () {
    console.log("  ------ start build features resource ------");

    try {
        const nativeResPath = path.resolve(__dirname, definition.TIANYU_NATIVE_NATIVE_RES_PATH);
        if (!fs.existsSync(nativeResPath)) {
            fs.mkdirSync(nativeResPath);
        }

        const nativeResFeaturePath = path.resolve(__dirname, FEATURE_RES_PATH_RELATION);
        if (!fs.existsSync(nativeResFeaturePath)) {
            fs.mkdirSync(nativeResFeaturePath);
        }

        await run();
    } catch (e) {
        console.error(`     create target failed: ${e.message}`);
    }

    console.log("  ------- build features resource end -------");
};
